<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Main HTML Document</title>
    <!-- Import p5.js from CDN -->
    <script src="https://cdn.jsdelivr.net/npm/p5@1.9.0/lib/p5.min.js"></script>
</head>
<body style="background-color: rgb(112, 201, 174); color: white; margin:0; padding:0; display: flex; justify-content: center; align-content: center;">
    <main>
        <!-- <h3 style="text-align: center;">TABUADAS (de 0 até 100)</h3>
        <div id="output" style="display: grid; grid-template-columns: 1fr 1fr 1fr 1fr; gap: 10px"></div> -->
    </main>
    <!-- <script type="module">
        import result from './main.js';
        document.getElementById('output').innerHTML = result;
    </script> -->
    <script>
        let balls = [];

        // Define colors and names for each ball
        const ballColors = [
            [255, 0, 0],    // Red
            [0, 0, 255],    // Blue
            [255, 255, 0],  // Yellow
            [255, 165, 0],  // Orange
            [128, 0, 128]   // Purple
        ];
        const ballNames = [
            "João",
            "Mateus",
            "Raquel",
            "Arthur",
            "Guilherme"
        ];

        // p5.js sketch to create a canvas and draw a ball in the center
        function setup() {
            createCanvas(windowWidth - 10, windowHeight - 10).parent(document.body);
            for (let i = 1; i <= 5; i++) {
                balls.push(new Ball(i * 50, 0, ballColors[i - 1], ballNames[i - 1]));
            }
        }

        let gravity = 0.5;
        let bounce = 0.7;
        let repelStrength = 1.5; // Adjust for stronger/weaker repulsion

        function windowResized() {
            resizeCanvas(windowWidth - 10, windowHeight - 10);
        }

        function draw() {
            background(255);
            fill(80, 185, 49);
            stroke(0);

            // Apply repulsion between balls
            for (let i = 0; i < balls.length; i++) {
                for (let j = i + 1; j < balls.length; j++) {
                    let b1 = balls[i];
                    let b2 = balls[j];
                    let dx = b2.posicaoHorizontal - b1.posicaoHorizontal;
                    let dy = b2.posicaoVertical - b1.posicaoVertical;
                    let distSq = dx * dx + dy * dy;
                    let minDist = (b1.ballTam + b2.ballTam) / 2;
                    if (distSq < minDist * minDist && distSq > 0) {
                        let distVal = sqrt(distSq);
                        let overlap = minDist - distVal;
                        // Normalize direction
                        let nx = dx / distVal;
                        let ny = dy / distVal;
                        // Push balls apart
                        b1.posicaoHorizontal -= nx * overlap / 2;
                        b1.posicaoVertical -= ny * overlap / 2;
                        b2.posicaoHorizontal += nx * overlap / 2;
                        b2.posicaoVertical += ny * overlap / 2;
                        // Add repulsion velocity
                        let force = repelStrength / distVal;
                        b1.velocityX -= nx * force;
                        b1.velocityY -= ny * force;
                        b2.velocityX += nx * force;
                        b2.velocityY += ny * force;
                    }
                }
            }

            for (let i = 0; i < balls.length; i++) {
                balls[i].draw();
            }
        }

        function mousePressed() {
            for (let i = 0; i < balls.length; i++) {
                balls[i].mousePressed();
            }
        }

        function mouseDragged() {
            for (let i = 0; i < balls.length; i++) {
                balls[i].mouseDragged();
            }
        }

        function mouseReleased() {
            for (let i = 0; i < balls.length; i++) {
                balls[i].mouseReleased();
            }
        }

        class Ball {
            posicaoHorizontal = 0;
            posicaoVertical = 0;
            ballTam = 40;
            isDragging = false;

            // Physics variables
            velocityY = 0;
            velocityX = 0;
            dragOffsetX = 0;
            dragOffsetY = 0;

            color = [255, 255, 255];
            name = "";

            constructor(horizontal, vertical, color, name) {
                this.posicaoHorizontal = horizontal;
                this.posicaoVertical = vertical;
                this.color = color;
                this.name = name;
                this.quica();
            }

            draw() {
                // Draw the ball
                fill(this.color);
                stroke(0);
                ellipse(this.posicaoHorizontal, this.posicaoVertical, this.ballTam, this.ballTam);

                // Draw the name centered on the ball
                fill(0);
                noStroke();
                textAlign(CENTER, CENTER);
                textSize(12);
                text(this.name, this.posicaoHorizontal, this.posicaoVertical);

                // Apply horizontal velocity (inertia)
                if (!this.isDragging) {
                    // Apply gravity
                    this.velocityY += gravity;
                    this.posicaoVertical += this.velocityY;

                    this.posicaoHorizontal += this.velocityX;
                    // Friction
                    this.velocityX *= 0.98;

                    this.quica();
                }
            }

            quica() {
                // Bounce on bottom
                if (this.posicaoVertical + this.ballTam / 2 > height) {
                    this.posicaoVertical = height - this.ballTam / 2;
                    this.velocityY *= -bounce;
                }

                // Bounce on top
                if (this.posicaoVertical - this.ballTam / 2 < 0) {
                    this.posicaoVertical = this.ballTam / 2;
                    this.velocityY *= -bounce;
                }

                // Bounce on sides
                if (this.posicaoHorizontal + this.ballTam / 2 > width) {
                    this.posicaoHorizontal = width - this.ballTam / 2;
                    this.velocityX *= -bounce;
                }
                if (this.posicaoHorizontal - this.ballTam / 2 < 0) {
                    this.posicaoHorizontal = this.ballTam / 2;
                    this.velocityX *= -bounce;
                }
            }

            mousePressed() {
                // Check if mouse is inside the ball
                let d = dist(mouseX, mouseY, this.posicaoHorizontal, this.posicaoVertical);
                if (d < this.ballTam / 2) {
                    this.isDragging = true;
                    this.dragOffsetX = this.posicaoHorizontal - mouseX;
                    this.dragOffsetY = this.posicaoVertical - mouseY;
                    this.velocityX = 0; // Stop inertia while dragging
                    this.velocityY = 0;
                }
            }

            mouseDragged() {
                if (this.isDragging) {
                    this.posicaoHorizontal = mouseX + this.dragOffsetX;
                    this.posicaoVertical = mouseY + this.dragOffsetY;
                    this.quica();
                }
            }

            mouseReleased() {
                if (this.isDragging) {
                    // Give velocity based on mouse movement
                    this.velocityX = movedX;
                    this.velocityY = movedY;
                    this.isDragging = false;
                }
            }
        }
    </script>
</body>
</html>